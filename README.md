<div align="center">

# ðŸ§  Simple 32-bit Operating System

## Bootable OS written in C and x86 Assembly â€” built to learn the fundamentals of low-level systems and how real kernels work.

![](https://img.shields.io/badge/C-00599C?style=for-the-badge&logo=c&logoColor=white)
![](https://img.shields.io/badge/x86_Assembly-6E4C13?style=for-the-badge)
![](https://img.shields.io/badge/NASM-000000?style=for-the-badge&logo=nasm&logoColor=white)
![](https://img.shields.io/badge/QEMU-FF6600?style=for-the-badge)
![](https://img.shields.io/badge/Makefile-000000?style=for-the-badge&logo=gnubash&logoColor=white)

</div>

---

<div align="center">
  <!-- Replace with your actual paths if adding screenshots -->
  <img src="images/img1.png" width="49%" />
  <img src="images/img2.png" width="49%" /> 
</div>

---

## ðŸ“˜ About

This project is a graphical 32-bit operating system built completely from scratch using NASM and C. It features a 16-bit bootloader, a C-based kernel, basic memory management, hardware-level keyboard/mouse input, double-buffered graphics, and cooperative multitasking. The OS runs entirely on bare-metal and is tested with QEMU.

---

## ðŸ› ï¸ Whatâ€™s Inside

- âœ… 16-bit bootloader written in Assembly that switches to protected mode
- âœ… C-based kernel loaded and executed with memory management setup
- âœ… Direct VGA memory access to display text and graphics
- âœ… Real-time hardware I/O handling (keyboard + mouse) using interrupts
- âœ… Double-buffered graphics for smooth animation rendering
- âœ… Cooperative multitasking (bouncing ball demo, etc.)
- âœ… Fully bootable `.img` file tested via QEMU

---

## ðŸ’¡ What I Learned

- How x86 CPU boots and switches modes (real â†’ protected)
- How bootloaders are written in NASM and assembled into raw binaries
- How a kernel is compiled with `gcc` and linked properly with a linker script
- How interrupts and hardware I/O are handled at the OS level
- How to build multitasking systems and basic window elements from scratch

---

## ðŸš€ Getting Started

### ðŸ”§ Prerequisites

- [NASM](https://www.nasm.us/)
- [GCC](https://gcc.gnu.org/)
- [QEMU](https://www.qemu.org/)
- `make`

**_1. Build the OS_**

```bash
make
```

**_2. Run using QEMU_**

```bash
qemu-system-i386 -fda os.img
```

**_3. Clean Build_**

```bash
make clean
```

> Removes all object files and the generated image.

---

## ðŸ“¦ Final Output

- The final output is a bootable floppy image os.img that can be run in any x86 emulator like QEMU or Bochs.

## Project Structure

```bash
/os
â”œâ”€â”€ os.img                    # Bootable OS image (generated by make)
â”œâ”€â”€ os.img.lock               # Lock file (ignored, auto-generated)
â”œâ”€â”€ boot/
â”‚   â”œâ”€â”€ bin/                  # Compiled binaries or utility executables
â”‚   â”œâ”€â”€ images/               # Assets such as bitmaps or font data
â”‚   â”œâ”€â”€ utilities/            # Helper functions or misc modules
â”‚   â”œâ”€â”€ boot.asm              # 16-bit bootloader to enter protected mode
â”‚   â”œâ”€â”€ final.c               # Optional final demo or integration logic
â”‚   â”œâ”€â”€ font.c                # Bitmap font rendering (character drawing)
â”‚   â”œâ”€â”€ graphics.c            # Core graphics logic (pixel-based drawing)
â”‚   â”œâ”€â”€ graphics_elements.c   # High-level UI elements (windows, boxes)
â”‚   â”œâ”€â”€ graphics.h            # Header file for graphics functions
â”‚   â”œâ”€â”€ input.c               # Keyboard and mouse I/O via interrupts
â”‚   â”œâ”€â”€ kernel_entry.asm      # ASM setup for C kernel handoff
â”‚   â”œâ”€â”€ main.c                # Kernel main loop and boot logic
â”‚   â”œâ”€â”€ makefile              # Build instructions (NASM + GCC + LD)
â”‚   â”œâ”€â”€ README.md             # Project documentation
â”‚   â”œâ”€â”€ task.c                # Cooperative multitasking (e.g., ball demo)
â”‚   â””â”€â”€ vbe-modex.txt         # VESA video mode config / test output
```
